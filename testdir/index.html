<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>スマホ向けオセロゲーム</title>
<style>
  body {
    margin:0; padding:0;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    background: #2e7d32;
    -webkit-tap-highlight-color: transparent;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    gap: 2px;
    background: #1b5e20;
    border: 4px solid #145214;
    border-radius: 8px;
    touch-action: manipulation;
  }
  .cell {
    width: 60px;
    height: 60px;
    background: #4caf50;
    border-radius: 4px;
    position: relative;
  }
  .cell:hover {
    background: #66bb6a;
    cursor: pointer;
  }
  .stone {
    position: absolute;
    top: 6px;
    left: 6px;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    box-shadow: inset 0 2px 5px rgba(255,255,255,0.5),
                0 2px 4px rgba(0,0,0,0.5);
  }
  .black {
    background: radial-gradient(circle at 30% 30%, #000, #222);
  }
  .white {
    background: radial-gradient(circle at 30% 30%, #fff, #ccc);
    border: 1.5px solid #999;
  }
  #status {
    margin-top: 20px;
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    text-align: center;
    user-select: none;
  }
  #resetBtn {
    margin-top: 15px;
    font-size: 16px;
    padding: 8px 16px;
    border-radius: 6px;
    border: none;
    background: #388e3c;
    color: white;
    cursor: pointer;
    user-select: none;
  }
  #resetBtn:hover {
    background: #4caf50;
  }
</style>
</head>
<body>

<div>
  <div id="board"></div>
  <div id="status">黒のターン</div>
  <button id="resetBtn">リセット</button>
</div>

<script>
const boardSize = 8;
let board = [];
let currentPlayer = 'black'; // 黒先手
const boardElem = document.getElementById('board');
const statusElem = document.getElementById('status');
const resetBtn = document.getElementById('resetBtn');

function initBoard() {
  board = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
  // 初期配置
  board[3][3] = 'white';
  board[3][4] = 'black';
  board[4][3] = 'black';
  board[4][4] = 'white';
}

function createCellElement(x, y) {
  const cell = document.createElement('div');
  cell.classList.add('cell');
  cell.dataset.x = x;
  cell.dataset.y = y;
  cell.addEventListener('click', () => {
    if(makeMove(x, y)) {
      switchPlayer();
      updateBoard();
      checkGameOver();
    }
  });
  return cell;
}

function drawBoard() {
  boardElem.innerHTML = '';
  for(let y=0; y<boardSize; y++){
    for(let x=0; x<boardSize; x++){
      const cell = createCellElement(x,y);
      if(board[y][x]){
        const stone = document.createElement('div');
        stone.classList.add('stone');
        stone.classList.add(board[y][x]);
        cell.appendChild(stone);
      }
      boardElem.appendChild(cell);
    }
  }
}

function onBoard(x, y){
  return x >= 0 && x < boardSize && y >= 0 && y < boardSize;
}

// 石を置けるかチェック、置いた場合は反転させる
function makeMove(x, y) {
  if(board[y][x] !== null) return false;
  const flips = getFlips(x, y, currentPlayer);
  if(flips.length === 0) return false;
  board[y][x] = currentPlayer;
  flips.forEach(([fx, fy]) => {
    board[fy][fx] = currentPlayer;
  });
  return true;
}

// 反転可能な石の座標一覧を取得
function getFlips(x, y, color) {
  const opponent = (color === 'black') ? 'white' : 'black';
  const directions = [
    [1,0], [-1,0], [0,1], [0,-1],
    [1,1], [-1,-1], [1,-1], [-1,1]
  ];
  let flips = [];
  for(const [dx, dy] of directions){
    let nx = x + dx;
    let ny = y + dy;
    let line = [];
    while(onBoard(nx, ny) && board[ny][nx] === opponent){
      line.push([nx, ny]);
      nx += dx; ny += dy;
    }
    if(onBoard(nx, ny) && board[ny][nx] === color && line.length > 0){
      flips = flips.concat(line);
    }
  }
  return flips;
}

function switchPlayer(){
  currentPlayer = (currentPlayer === 'black') ? 'white' : 'black';
  if(!canPlayerMove(currentPlayer)){
    // 相手が打てないならパスして元に戻す
    if(!canPlayerMove(opponent(currentPlayer))){
      // どちらも打てなければ終了判定
      currentPlayer = null;
    } else {
      currentPlayer = opponent(currentPlayer);
      alert('相手は打てないためパスしました');
    }
  }
  updateStatus();
}

function opponent(color){
  return color === 'black' ? 'white' : 'black';
}

function canPlayerMove(color){
  for(let y=0; y<boardSize; y++){
    for(let x=0; x<boardSize; x++){
      if(board[y][x] === null){
        if(getFlips(x,y,color).length > 0) return true;
      }
    }
  }
  return false;
}

function updateBoard(){
  drawBoard();
}

function updateStatus(){
  if(currentPlayer === null){
    const blackCount = countStones('black');
    const whiteCount = countStones('white');
    if(blackCount > whiteCount) statusElem.textContent = `黒の勝ち！ ${blackCount} : ${whiteCount}`;
    else if(whiteCount > blackCount) statusElem.textContent = `白の勝ち！ ${whiteCount} : ${blackCount}`;
    else statusElem.textContent = `引き分け！ ${blackCount} : ${whiteCount}`;
  } else {
    statusElem.textContent = `${currentPlayer === 'black' ? '黒' : '白'}のターン`;
  }
}

function countStones(color){
  let cnt = 0;
  for(let y=0; y<boardSize; y++){
    for(let x=0; x<boardSize; x++){
      if(board[y][x] === color) cnt++;
    }
  }
  return cnt;
}

function checkGameOver(){
  if(currentPlayer === null){
    alert('ゲーム終了です！リセットボタンで再スタートできます。');
  }
}

resetBtn.addEventListener('click', () => {
  initBoard();
  currentPlayer = 'black';
  updateBoard();
  updateStatus();
});

// 初期化
initBoard();
updateBoard();
updateStatus();
</script>

</body>
</html>
